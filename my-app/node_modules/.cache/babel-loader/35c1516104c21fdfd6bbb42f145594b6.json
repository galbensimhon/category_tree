{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport { __assign, __extends, __values } from \"tslib\";\nimport { AnimationFrame } from '@material/animation/animationframe';\nimport { MDCFoundation } from '@material/base/foundation';\nimport { KEY, normalizeKey } from '@material/dom/keyboard';\nimport { AnchorBoundaryType, attributes, CssClasses, numbers, XPosition, YPosition } from './constants';\nvar RICH = CssClasses.RICH,\n    SHOWN = CssClasses.SHOWN,\n    SHOWING = CssClasses.SHOWING,\n    SHOWING_TRANSITION = CssClasses.SHOWING_TRANSITION,\n    HIDE = CssClasses.HIDE,\n    HIDE_TRANSITION = CssClasses.HIDE_TRANSITION,\n    MULTILINE_TOOLTIP = CssClasses.MULTILINE_TOOLTIP;\nvar AnimationKeys;\n\n(function (AnimationKeys) {\n  AnimationKeys[\"POLL_ANCHOR\"] = \"poll_anchor\";\n})(AnimationKeys || (AnimationKeys = {}));\n\nvar MDCTooltipFoundation =\n/** @class */\nfunction (_super) {\n  __extends(MDCTooltipFoundation, _super);\n\n  function MDCTooltipFoundation(adapter) {\n    var _this = _super.call(this, __assign(__assign({}, MDCTooltipFoundation.defaultAdapter), adapter)) || this;\n\n    _this.isShown = false;\n    _this.anchorGap = numbers.BOUNDED_ANCHOR_GAP;\n    _this.xTooltipPos = XPosition.DETECTED;\n    _this.yTooltipPos = YPosition.DETECTED; // Minimum threshold distance needed between the tooltip and the viewport.\n\n    _this.minViewportTooltipThreshold = numbers.MIN_VIEWPORT_TOOLTIP_THRESHOLD;\n    _this.hideDelayMs = numbers.HIDE_DELAY_MS;\n    _this.showDelayMs = numbers.SHOW_DELAY_MS;\n    _this.anchorRect = null;\n    _this.frameId = null;\n    _this.hideTimeout = null;\n    _this.showTimeout = null;\n    _this.animFrame = new AnimationFrame();\n\n    _this.documentClickHandler = function (evt) {\n      _this.handleDocumentClick(evt);\n    };\n\n    _this.documentKeydownHandler = function (evt) {\n      _this.handleKeydown(evt);\n    };\n\n    _this.richTooltipMouseEnterHandler = function () {\n      _this.handleRichTooltipMouseEnter();\n    };\n\n    _this.richTooltipMouseLeaveHandler = function () {\n      _this.handleRichTooltipMouseLeave();\n    };\n\n    _this.richTooltipFocusOutHandler = function (evt) {\n      _this.handleRichTooltipFocusOut(evt);\n    };\n\n    _this.windowScrollHandler = function () {\n      _this.handleWindowChangeEvent();\n    };\n\n    _this.windowResizeHandler = function () {\n      _this.handleWindowChangeEvent();\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(MDCTooltipFoundation, \"defaultAdapter\", {\n    get: function () {\n      return {\n        getAttribute: function () {\n          return null;\n        },\n        setAttribute: function () {\n          return undefined;\n        },\n        addClass: function () {\n          return undefined;\n        },\n        hasClass: function () {\n          return false;\n        },\n        removeClass: function () {\n          return undefined;\n        },\n        setStyleProperty: function () {\n          return undefined;\n        },\n        getViewportWidth: function () {\n          return 0;\n        },\n        getViewportHeight: function () {\n          return 0;\n        },\n        getTooltipSize: function () {\n          return {\n            width: 0,\n            height: 0\n          };\n        },\n        getAnchorBoundingRect: function () {\n          return {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            width: 0,\n            height: 0\n          };\n        },\n        getAnchorAttribute: function () {\n          return null;\n        },\n        setAnchorAttribute: function () {\n          return null;\n        },\n        isRTL: function () {\n          return false;\n        },\n        anchorContainsElement: function () {\n          return false;\n        },\n        tooltipContainsElement: function () {\n          return false;\n        },\n        focusAnchorElement: function () {\n          return undefined;\n        },\n        registerEventHandler: function () {\n          return undefined;\n        },\n        deregisterEventHandler: function () {\n          return undefined;\n        },\n        registerDocumentEventHandler: function () {\n          return undefined;\n        },\n        deregisterDocumentEventHandler: function () {\n          return undefined;\n        },\n        registerWindowEventHandler: function () {\n          return undefined;\n        },\n        deregisterWindowEventHandler: function () {\n          return undefined;\n        },\n        notifyHidden: function () {\n          return undefined;\n        }\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MDCTooltipFoundation.prototype.init = function () {\n    this.isRich = this.adapter.hasClass(RICH);\n    this.isPersistent = this.adapter.getAttribute(attributes.PERSISTENT) === 'true';\n    this.isInteractive = !!this.adapter.getAnchorAttribute(attributes.ARIA_EXPANDED) && this.adapter.getAnchorAttribute(attributes.ARIA_HASPOPUP) === 'true';\n  };\n\n  MDCTooltipFoundation.prototype.getIsRich = function () {\n    return this.isRich;\n  };\n\n  MDCTooltipFoundation.prototype.getIsPersistent = function () {\n    return this.isPersistent;\n  };\n\n  MDCTooltipFoundation.prototype.handleAnchorMouseEnter = function () {\n    var _this = this;\n\n    if (this.isShown) {\n      // Covers the instance where a user hovers over the anchor to reveal the\n      // tooltip, and then quickly navigates away and then back to the anchor.\n      // The tooltip should stay visible without animating out and then back in\n      // again.\n      this.show();\n    } else {\n      this.showTimeout = setTimeout(function () {\n        _this.show();\n      }, this.showDelayMs);\n    }\n  };\n\n  MDCTooltipFoundation.prototype.handleAnchorFocus = function (evt) {\n    var _this = this; // TODO(b/157075286): Need to add some way to distinguish keyboard\n    // navigation focus events from other focus events, and only show the\n    // tooltip on the former of these events.\n\n\n    var relatedTarget = evt.relatedTarget;\n    var tooltipContainsRelatedTarget = relatedTarget instanceof HTMLElement && this.adapter.tooltipContainsElement(relatedTarget); // Do not show tooltip if the previous focus was on a tooltip element. This\n    // occurs when a rich tooltip is closed and focus is restored to the anchor\n    // or when user tab-navigates back into the anchor from the rich tooltip.\n\n    if (tooltipContainsRelatedTarget) {\n      return;\n    }\n\n    this.showTimeout = setTimeout(function () {\n      _this.show();\n    }, this.showDelayMs);\n  };\n\n  MDCTooltipFoundation.prototype.handleAnchorMouseLeave = function () {\n    var _this = this;\n\n    this.clearShowTimeout();\n    this.hideTimeout = setTimeout(function () {\n      _this.hide();\n    }, this.hideDelayMs);\n  };\n\n  MDCTooltipFoundation.prototype.handleAnchorBlur = function (evt) {\n    if (this.isRich) {\n      var tooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement && this.adapter.tooltipContainsElement(evt.relatedTarget); // If focus changed to the tooltip element, don't hide the tooltip.\n\n      if (tooltipContainsRelatedTargetElement) {\n        return;\n      }\n    } // Hide tooltip immediately on focus change.\n\n\n    this.hide();\n  };\n\n  MDCTooltipFoundation.prototype.handleAnchorClick = function () {\n    if (this.isShown) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  };\n\n  MDCTooltipFoundation.prototype.handleDocumentClick = function (evt) {\n    var anchorOrTooltipContainsTargetElement = evt.target instanceof HTMLElement && (this.adapter.anchorContainsElement(evt.target) || this.adapter.tooltipContainsElement(evt.target)); // For persistent rich tooltips, we will not hide if:\n    // - The click target is within the anchor element. Otherwise, both\n    //   the anchor element's click handler and this handler will handle the\n    //   click (due to event propagation), resulting in a shown tooltip\n    //   being immediately hidden if the tooltip was initially hidden.\n    // - The click target is within the tooltip element, since clicks\n    //   on the tooltip do not close the tooltip.\n\n    if (this.isRich && this.isPersistent && anchorOrTooltipContainsTargetElement) {\n      return;\n    } // Hide the tooltip immediately on click.\n\n\n    this.hide();\n  };\n\n  MDCTooltipFoundation.prototype.handleKeydown = function (evt) {\n    // Hide the tooltip immediately on ESC key.\n    var key = normalizeKey(evt);\n\n    if (key === KEY.ESCAPE) {\n      var tooltipContainsActiveElement = document.activeElement instanceof HTMLElement && this.adapter.tooltipContainsElement(document.activeElement);\n\n      if (tooltipContainsActiveElement) {\n        this.adapter.focusAnchorElement();\n      }\n\n      this.hide();\n    }\n  };\n\n  MDCTooltipFoundation.prototype.handleRichTooltipMouseEnter = function () {\n    this.show();\n  };\n\n  MDCTooltipFoundation.prototype.handleRichTooltipMouseLeave = function () {\n    var _this = this;\n\n    this.clearShowTimeout();\n    this.hideTimeout = setTimeout(function () {\n      _this.hide();\n    }, this.hideDelayMs);\n  };\n\n  MDCTooltipFoundation.prototype.handleRichTooltipFocusOut = function (evt) {\n    var anchorOrTooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement && (this.adapter.anchorContainsElement(evt.relatedTarget) || this.adapter.tooltipContainsElement(evt.relatedTarget)); // If the focus is still within the anchor or the tooltip, do not hide the\n    // tooltip.\n\n    if (anchorOrTooltipContainsRelatedTargetElement) {\n      return;\n    }\n\n    this.hide();\n  };\n  /**\n   * On window resize or scroll, check the anchor position and size and\n   * repostion tooltip if necessary.\n   */\n\n\n  MDCTooltipFoundation.prototype.handleWindowChangeEvent = function () {\n    var _this = this; // Since scroll and resize events can fire at a high rate, we throttle\n    // the potential re-positioning of tooltip component using\n    // requestAnimationFrame.\n\n\n    this.animFrame.request(AnimationKeys.POLL_ANCHOR, function () {\n      _this.repositionTooltipOnAnchorMove();\n    });\n  };\n\n  MDCTooltipFoundation.prototype.show = function () {\n    var _this = this;\n\n    this.clearHideTimeout();\n    this.clearShowTimeout();\n\n    if (this.isShown) {\n      return;\n    }\n\n    this.isShown = true;\n    var showTooltipOptions = this.parseShowTooltipOptions();\n\n    if (!showTooltipOptions.hideFromScreenreader) {\n      this.adapter.setAttribute('aria-hidden', 'false');\n    }\n\n    if (this.isRich) {\n      if (this.isInteractive) {\n        this.adapter.setAnchorAttribute('aria-expanded', 'true');\n      }\n\n      this.adapter.registerEventHandler('focusout', this.richTooltipFocusOutHandler);\n\n      if (!this.isPersistent) {\n        this.adapter.registerEventHandler('mouseenter', this.richTooltipMouseEnterHandler);\n        this.adapter.registerEventHandler('mouseleave', this.richTooltipMouseLeaveHandler);\n      }\n    }\n\n    this.adapter.removeClass(HIDE);\n    this.adapter.addClass(SHOWING);\n\n    if (this.isTooltipMultiline() && !this.isRich) {\n      this.adapter.addClass(MULTILINE_TOOLTIP);\n    }\n\n    this.anchorRect = this.adapter.getAnchorBoundingRect();\n    this.positionTooltip();\n    this.adapter.registerDocumentEventHandler('click', this.documentClickHandler);\n    this.adapter.registerDocumentEventHandler('keydown', this.documentKeydownHandler);\n    this.adapter.registerWindowEventHandler('scroll', this.windowScrollHandler);\n    this.adapter.registerWindowEventHandler('resize', this.windowResizeHandler);\n    this.frameId = requestAnimationFrame(function () {\n      _this.clearAllAnimationClasses();\n\n      _this.adapter.addClass(SHOWN);\n\n      _this.adapter.addClass(SHOWING_TRANSITION);\n    });\n  };\n\n  MDCTooltipFoundation.prototype.hide = function () {\n    this.clearHideTimeout();\n    this.clearShowTimeout();\n\n    if (!this.isShown) {\n      return;\n    }\n\n    if (this.frameId) {\n      cancelAnimationFrame(this.frameId);\n    }\n\n    this.isShown = false;\n    this.adapter.setAttribute('aria-hidden', 'true');\n    this.adapter.deregisterEventHandler('focusout', this.richTooltipFocusOutHandler);\n\n    if (this.isRich) {\n      if (this.isInteractive) {\n        this.adapter.setAnchorAttribute('aria-expanded', 'false');\n      }\n\n      if (!this.isPersistent) {\n        this.adapter.deregisterEventHandler('mouseenter', this.richTooltipMouseEnterHandler);\n        this.adapter.deregisterEventHandler('mouseleave', this.richTooltipMouseLeaveHandler);\n      }\n    }\n\n    this.clearAllAnimationClasses();\n    this.adapter.addClass(HIDE);\n    this.adapter.addClass(HIDE_TRANSITION);\n    this.adapter.removeClass(SHOWN);\n    this.adapter.deregisterDocumentEventHandler('click', this.documentClickHandler);\n    this.adapter.deregisterDocumentEventHandler('keydown', this.documentKeydownHandler);\n    this.adapter.deregisterWindowEventHandler('scroll', this.windowScrollHandler);\n    this.adapter.deregisterWindowEventHandler('resize', this.windowResizeHandler);\n  };\n\n  MDCTooltipFoundation.prototype.handleTransitionEnd = function () {\n    var isHidingTooltip = this.adapter.hasClass(HIDE);\n    this.adapter.removeClass(SHOWING);\n    this.adapter.removeClass(SHOWING_TRANSITION);\n    this.adapter.removeClass(HIDE);\n    this.adapter.removeClass(HIDE_TRANSITION); // If handleTransitionEnd is called after hiding the tooltip, the tooltip\n    // will have the HIDE class (before calling the adapter removeClass method).\n    // If tooltip is now hidden, send a notification that the animation has\n    // completed and the tooltip is no longer visible.\n\n    if (isHidingTooltip) {\n      this.adapter.notifyHidden();\n    }\n  };\n\n  MDCTooltipFoundation.prototype.clearAllAnimationClasses = function () {\n    this.adapter.removeClass(SHOWING_TRANSITION);\n    this.adapter.removeClass(HIDE_TRANSITION);\n  };\n\n  MDCTooltipFoundation.prototype.setTooltipPosition = function (position) {\n    var xPos = position.xPos,\n        yPos = position.yPos;\n\n    if (xPos) {\n      this.xTooltipPos = xPos;\n    }\n\n    if (yPos) {\n      this.yTooltipPos = yPos;\n    }\n  };\n\n  MDCTooltipFoundation.prototype.setAnchorBoundaryType = function (type) {\n    if (type === AnchorBoundaryType.UNBOUNDED) {\n      this.anchorGap = numbers.UNBOUNDED_ANCHOR_GAP;\n    } else {\n      this.anchorGap = numbers.BOUNDED_ANCHOR_GAP;\n    }\n  };\n\n  MDCTooltipFoundation.prototype.parseShowTooltipOptions = function () {\n    var hideFromScreenreader = Boolean(this.adapter.getAnchorAttribute('data-tooltip-id'));\n    return {\n      hideFromScreenreader: hideFromScreenreader\n    };\n  };\n\n  MDCTooltipFoundation.prototype.isTooltipMultiline = function () {\n    var tooltipSize = this.adapter.getTooltipSize();\n    return tooltipSize.height > numbers.MIN_HEIGHT && tooltipSize.width >= numbers.MAX_WIDTH;\n  };\n\n  MDCTooltipFoundation.prototype.positionTooltip = function () {\n    var _a = this.calculateTooltipDistance(this.anchorRect),\n        top = _a.top,\n        left = _a.left;\n\n    this.adapter.setStyleProperty('top', top + \"px\");\n    this.adapter.setStyleProperty('left', left + \"px\");\n  };\n  /**\n   * Calculates the position of the tooltip. A tooltip will be placed beneath\n   * the anchor element and aligned either with the 'start'/'end' edge of the\n   * anchor element or the 'center'.\n   *\n   * Tooltip alignment is selected such that the tooltip maintains a threshold\n   * distance away from the viewport (defaulting to 'center' alignment). If the\n   * placement of the anchor prevents this threshold distance from being\n   * maintained, the tooltip is positioned so that it does not collide with the\n   * viewport.\n   *\n   * Users can specify an alignment, however, if this alignment results in the\n   * tooltip colliding with the viewport, this specification is overwritten.\n   */\n\n\n  MDCTooltipFoundation.prototype.calculateTooltipDistance = function (anchorRect) {\n    if (!anchorRect) {\n      return {\n        top: 0,\n        left: 0\n      };\n    }\n\n    var tooltipSize = this.adapter.getTooltipSize();\n    var top = this.calculateYTooltipDistance(anchorRect, tooltipSize.height);\n    var left = this.calculateXTooltipDistance(anchorRect, tooltipSize.width);\n    return {\n      top: top,\n      left: left\n    };\n  };\n  /**\n   * Calculates the `left` distance for the tooltip.\n   */\n\n\n  MDCTooltipFoundation.prototype.calculateXTooltipDistance = function (anchorRect, tooltipWidth) {\n    var isLTR = !this.adapter.isRTL();\n    var startPos, endPos, centerPos;\n\n    if (this.isRich) {\n      startPos = isLTR ? anchorRect.left - tooltipWidth : anchorRect.right;\n      endPos = isLTR ? anchorRect.right : anchorRect.left - tooltipWidth;\n    } else {\n      startPos = isLTR ? anchorRect.left : anchorRect.right - tooltipWidth;\n      endPos = isLTR ? anchorRect.right - tooltipWidth : anchorRect.left;\n      centerPos = anchorRect.left + (anchorRect.width - tooltipWidth) / 2;\n    }\n\n    var positionOptions = this.isRich ? this.determineValidPositionOptions(startPos, endPos) : // For plain tooltips, centerPos is defined\n    this.determineValidPositionOptions(centerPos, startPos, endPos);\n\n    if (this.xTooltipPos === XPosition.START && positionOptions.has(startPos)) {\n      return startPos;\n    }\n\n    if (this.xTooltipPos === XPosition.END && positionOptions.has(endPos)) {\n      return endPos;\n    }\n\n    if (this.xTooltipPos === XPosition.CENTER && positionOptions.has(centerPos)) {\n      return centerPos;\n    } // If no user position is supplied, rich tooltips default to end pos, then\n    // start position. Plain tooltips default to center, start, then end.\n\n\n    var possiblePositions = this.isRich ? [endPos, startPos] : [centerPos, startPos, endPos];\n    var validPosition = possiblePositions.find(function (pos) {\n      return positionOptions.has(pos);\n    });\n\n    if (validPosition) {\n      return validPosition;\n    } // Indicates that all potential positions would result in the tooltip\n    // colliding with the viewport. This would only occur when the anchor\n    // element itself collides with the viewport, or the viewport is very\n    // narrow. In this case, we allow the tooltip to be mis-aligned from the\n    // anchor element.\n\n\n    if (anchorRect.left < 0) {\n      return this.minViewportTooltipThreshold;\n    } else {\n      var viewportWidth = this.adapter.getViewportWidth();\n      return viewportWidth - (tooltipWidth + this.minViewportTooltipThreshold);\n    }\n  };\n  /**\n   * Given the values for the horizontal alignments of the tooltip, calculates\n   * which of these options would result in the tooltip maintaining the required\n   * threshold distance vs which would result in the tooltip staying within the\n   * viewport.\n   *\n   * A Set of values is returned holding the distances that would honor the\n   * above requirements. Following the logic for determining the tooltip\n   * position, if all alignments violate the threshold, then the returned Set\n   * contains values that keep the tooltip within the viewport.\n   */\n\n\n  MDCTooltipFoundation.prototype.determineValidPositionOptions = function () {\n    var e_1, _a;\n\n    var positions = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      positions[_i] = arguments[_i];\n    }\n\n    var posWithinThreshold = new Set();\n    var posWithinViewport = new Set();\n\n    try {\n      for (var positions_1 = __values(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {\n        var position = positions_1_1.value;\n\n        if (this.positionHonorsViewportThreshold(position)) {\n          posWithinThreshold.add(position);\n        } else if (this.positionDoesntCollideWithViewport(position)) {\n          posWithinViewport.add(position);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (positions_1_1 && !positions_1_1.done && (_a = positions_1.return)) _a.call(positions_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;\n  };\n\n  MDCTooltipFoundation.prototype.positionHonorsViewportThreshold = function (leftPos) {\n    var viewportWidth = this.adapter.getViewportWidth();\n    var tooltipWidth = this.adapter.getTooltipSize().width;\n    return leftPos + tooltipWidth <= viewportWidth - this.minViewportTooltipThreshold && leftPos >= this.minViewportTooltipThreshold;\n  };\n\n  MDCTooltipFoundation.prototype.positionDoesntCollideWithViewport = function (leftPos) {\n    var viewportWidth = this.adapter.getViewportWidth();\n    var tooltipWidth = this.adapter.getTooltipSize().width;\n    return leftPos + tooltipWidth <= viewportWidth && leftPos >= 0;\n  };\n  /**\n   * Calculates the `top` distance for the tooltip.\n   */\n\n\n  MDCTooltipFoundation.prototype.calculateYTooltipDistance = function (anchorRect, tooltipHeight) {\n    var belowYPos = anchorRect.bottom + this.anchorGap;\n    var aboveYPos = anchorRect.top - (this.anchorGap + tooltipHeight);\n    var yPositionOptions = this.determineValidYPositionOptions(aboveYPos, belowYPos);\n\n    if (this.yTooltipPos === YPosition.ABOVE && yPositionOptions.has(aboveYPos)) {\n      return aboveYPos;\n    } else if (this.yTooltipPos === YPosition.BELOW && yPositionOptions.has(belowYPos)) {\n      return belowYPos;\n    }\n\n    if (yPositionOptions.has(belowYPos)) {\n      return belowYPos;\n    }\n\n    if (yPositionOptions.has(aboveYPos)) {\n      return aboveYPos;\n    } // Indicates that all potential positions would result in the tooltip\n    // colliding with the viewport. This would only occur when the viewport is\n    // very short.\n\n\n    return belowYPos;\n  };\n  /**\n   * Given the values for above/below alignment of the tooltip, calculates\n   * which of these options would result in the tooltip maintaining the required\n   * threshold distance vs which would result in the tooltip staying within the\n   * viewport.\n   *\n   * A Set of values is returned holding the distances that would honor the\n   * above requirements. Following the logic for determining the tooltip\n   * position, if all possible alignments violate the threshold, then the\n   * returned Set contains values that keep the tooltip within the viewport.\n   */\n\n\n  MDCTooltipFoundation.prototype.determineValidYPositionOptions = function (aboveAnchorPos, belowAnchorPos) {\n    var posWithinThreshold = new Set();\n    var posWithinViewport = new Set();\n\n    if (this.yPositionHonorsViewportThreshold(aboveAnchorPos)) {\n      posWithinThreshold.add(aboveAnchorPos);\n    } else if (this.yPositionDoesntCollideWithViewport(aboveAnchorPos)) {\n      posWithinViewport.add(aboveAnchorPos);\n    }\n\n    if (this.yPositionHonorsViewportThreshold(belowAnchorPos)) {\n      posWithinThreshold.add(belowAnchorPos);\n    } else if (this.yPositionDoesntCollideWithViewport(belowAnchorPos)) {\n      posWithinViewport.add(belowAnchorPos);\n    }\n\n    return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;\n  };\n\n  MDCTooltipFoundation.prototype.yPositionHonorsViewportThreshold = function (yPos) {\n    var viewportHeight = this.adapter.getViewportHeight();\n    var tooltipHeight = this.adapter.getTooltipSize().height;\n    return yPos + tooltipHeight + this.minViewportTooltipThreshold <= viewportHeight && yPos >= this.minViewportTooltipThreshold;\n  };\n\n  MDCTooltipFoundation.prototype.yPositionDoesntCollideWithViewport = function (yPos) {\n    var viewportHeight = this.adapter.getViewportHeight();\n    var tooltipHeight = this.adapter.getTooltipSize().height;\n    return yPos + tooltipHeight <= viewportHeight && yPos >= 0;\n  };\n\n  MDCTooltipFoundation.prototype.repositionTooltipOnAnchorMove = function () {\n    var newAnchorRect = this.adapter.getAnchorBoundingRect();\n    if (!newAnchorRect || !this.anchorRect) return;\n\n    if (newAnchorRect.top !== this.anchorRect.top || newAnchorRect.left !== this.anchorRect.left || newAnchorRect.height !== this.anchorRect.height || newAnchorRect.width !== this.anchorRect.width) {\n      this.anchorRect = newAnchorRect;\n      this.positionTooltip();\n    }\n  };\n\n  MDCTooltipFoundation.prototype.clearShowTimeout = function () {\n    if (this.showTimeout) {\n      clearTimeout(this.showTimeout);\n      this.showTimeout = null;\n    }\n  };\n\n  MDCTooltipFoundation.prototype.clearHideTimeout = function () {\n    if (this.hideTimeout) {\n      clearTimeout(this.hideTimeout);\n      this.hideTimeout = null;\n    }\n  };\n\n  MDCTooltipFoundation.prototype.destroy = function () {\n    if (this.frameId) {\n      cancelAnimationFrame(this.frameId);\n      this.frameId = null;\n    }\n\n    this.clearHideTimeout();\n    this.clearShowTimeout();\n    this.adapter.removeClass(SHOWN);\n    this.adapter.removeClass(SHOWING_TRANSITION);\n    this.adapter.removeClass(SHOWING);\n    this.adapter.removeClass(HIDE);\n    this.adapter.removeClass(HIDE_TRANSITION);\n\n    if (this.isRich) {\n      this.adapter.deregisterEventHandler('focusout', this.richTooltipFocusOutHandler);\n\n      if (!this.isPersistent) {\n        this.adapter.deregisterEventHandler('mouseenter', this.richTooltipMouseEnterHandler);\n        this.adapter.deregisterEventHandler('mouseleave', this.richTooltipMouseLeaveHandler);\n      }\n    }\n\n    this.adapter.deregisterDocumentEventHandler('click', this.documentClickHandler);\n    this.adapter.deregisterDocumentEventHandler('keydown', this.documentKeydownHandler);\n    this.adapter.deregisterWindowEventHandler('scroll', this.windowScrollHandler);\n    this.adapter.deregisterWindowEventHandler('resize', this.windowResizeHandler);\n    this.animFrame.cancelAll();\n  };\n\n  return MDCTooltipFoundation;\n}(MDCFoundation);\n\nexport { MDCTooltipFoundation }; // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n\nexport default MDCTooltipFoundation;","map":{"version":3,"sources":["foundation.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;AAqBG;;AAEH,SAAQ,cAAR,QAA6B,oCAA7B;AACA,SAAQ,aAAR,QAA4B,2BAA5B;AAEA,SAAQ,GAAR,EAAa,YAAb,QAAgC,wBAAhC;AAGA,SAAQ,kBAAR,EAA4B,UAA5B,EAAwC,UAAxC,EAAoD,OAApD,EAA6D,SAA7D,EAAwE,SAAxE,QAAwF,aAAxF;AAIE,IAAA,IAAA,GAAA,UAAA,CAAA,IAAA;AAAA,IACA,KAAA,GAAA,UAAA,CAAA,KADA;AAAA,IAEA,OAAA,GAAA,UAAA,CAAA,OAFA;AAAA,IAGA,kBAAA,GAAA,UAAA,CAAA,kBAHA;AAAA,IAIA,IAAA,GAAA,UAAA,CAAA,IAJA;AAAA,IAKA,eAAA,GAAA,UAAA,CAAA,eALA;AAAA,IAMA,iBAAA,GAAA,UAAA,CAAA,iBANA;AASF,IAAK,aAAL;;AAAA,CAAA,UAAK,aAAL,EAAkB;AAChB,EAAA,aAAA,CAAA,aAAA,CAAA,GAAA,aAAA;AACD,CAFD,EAAK,aAAa,KAAb,aAAa,GAAA,EAAA,CAAlB;;AAIA,IAAA,oBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA0C,EAAA,SAAA,CAAA,oBAAA,EAAA,MAAA,CAAA;;AA2DxC,WAAA,oBAAA,CAAY,OAAZ,EAAgD;AAAhD,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAU,oBAAoB,CAAC,cAA/B,CAAA,EAAkD,OAAlD,CAAA,KAA2D,IAD7D;;AA1BQ,IAAA,KAAA,CAAA,OAAA,GAAU,KAAV;AACA,IAAA,KAAA,CAAA,SAAA,GAAY,OAAO,CAAC,kBAApB;AACA,IAAA,KAAA,CAAA,WAAA,GAAc,SAAS,CAAC,QAAxB;AACA,IAAA,KAAA,CAAA,WAAA,GAAc,SAAS,CAAC,QAAxB,CAuBwC,CAtBhD;;AACiB,IAAA,KAAA,CAAA,2BAAA,GACb,OAAO,CAAC,8BADK;AAEA,IAAA,KAAA,CAAA,WAAA,GAAc,OAAO,CAAC,aAAtB;AACA,IAAA,KAAA,CAAA,WAAA,GAAc,OAAO,CAAC,aAAtB;AAET,IAAA,KAAA,CAAA,UAAA,GAA8B,IAA9B;AACA,IAAA,KAAA,CAAA,OAAA,GAAuB,IAAvB;AACA,IAAA,KAAA,CAAA,WAAA,GAA2B,IAA3B;AACA,IAAA,KAAA,CAAA,WAAA,GAA2B,IAA3B;AAeN,IAAA,KAAI,CAAC,SAAL,GAAiB,IAAI,cAAJ,EAAjB;;AAEA,IAAA,KAAI,CAAC,oBAAL,GAA4B,UAAC,GAAD,EAAI;AAC9B,MAAA,KAAI,CAAC,mBAAL,CAAyB,GAAzB;AACD,KAFD;;AAIA,IAAA,KAAI,CAAC,sBAAL,GAA8B,UAAC,GAAD,EAAI;AAChC,MAAA,KAAI,CAAC,aAAL,CAAmB,GAAnB;AACD,KAFD;;AAIA,IAAA,KAAI,CAAC,4BAAL,GAAoC,YAAA;AAClC,MAAA,KAAI,CAAC,2BAAL;AACD,KAFD;;AAIA,IAAA,KAAI,CAAC,4BAAL,GAAoC,YAAA;AAClC,MAAA,KAAI,CAAC,2BAAL;AACD,KAFD;;AAIA,IAAA,KAAI,CAAC,0BAAL,GAAkC,UAAC,GAAD,EAAI;AACpC,MAAA,KAAI,CAAC,yBAAL,CAA+B,GAA/B;AACD,KAFD;;AAIA,IAAA,KAAI,CAAC,mBAAL,GAA2B,YAAA;AACzB,MAAA,KAAI,CAAC,uBAAL;AACD,KAFD;;AAIA,IAAA,KAAI,CAAC,mBAAL,GAA2B,YAAA;AACzB,MAAA,KAAI,CAAC,uBAAL;AACD,KAFD;;;AAGD;;AAzFD,EAAA,MAAA,CAAA,cAAA,CAAW,oBAAX,EAAW,gBAAX,EAAyB;SAAzB,YAAA;AACE,aAAO;AACL,QAAA,YAAY,EAAE,YAAA;AAAM,iBAAA,IAAA;AAAI,SADnB;AAEL,QAAA,YAAY,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS,SAFxB;AAGL,QAAA,QAAQ,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS,SAHpB;AAIL,QAAA,QAAQ,EAAE,YAAA;AAAM,iBAAA,KAAA;AAAK,SAJhB;AAKL,QAAA,WAAW,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS,SALvB;AAML,QAAA,gBAAgB,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS,SAN5B;AAOL,QAAA,gBAAgB,EAAE,YAAA;AAAM,iBAAA,CAAA;AAAC,SAPpB;AAQL,QAAA,iBAAiB,EAAE,YAAA;AAAM,iBAAA,CAAA;AAAC,SARrB;AASL,QAAA,cAAc,EAAE,YAAA;AAAM,iBAAC;AAAC,YAAA,KAAK,EAAE,CAAR;AAAW,YAAA,MAAM,EAAlB;AAAC,WAAD;AAAuB,SATxC;AAUL,QAAA,qBAAqB,EAAE,YAAA;AACnB,iBAAC;AAAC,YAAA,GAAG,EAAE,CAAN;AAAS,YAAA,KAAK,EAAE,CAAhB;AAAmB,YAAA,MAAM,EAAE,CAA3B;AAA8B,YAAA,IAAI,EAAE,CAApC;AAAuC,YAAA,KAAK,EAAE,CAA9C;AAAiD,YAAA,MAAM,EAAE;AAAzD,WAAD;AAA6D,SAX5D;AAYL,QAAA,kBAAkB,EAAE,YAAA;AAAM,iBAAA,IAAA;AAAI,SAZzB;AAaL,QAAA,kBAAkB,EAAE,YAAA;AAAM,iBAAA,IAAA;AAAI,SAbzB;AAcL,QAAA,KAAK,EAAE,YAAA;AAAM,iBAAA,KAAA;AAAK,SAdb;AAeL,QAAA,qBAAqB,EAAE,YAAA;AAAM,iBAAA,KAAA;AAAK,SAf7B;AAgBL,QAAA,sBAAsB,EAAE,YAAA;AAAM,iBAAA,KAAA;AAAK,SAhB9B;AAiBL,QAAA,kBAAkB,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS,SAjB9B;AAkBL,QAAA,oBAAoB,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS,SAlBhC;AAmBL,QAAA,sBAAsB,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS,SAnBlC;AAoBL,QAAA,4BAA4B,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS,SApBxC;AAqBL,QAAA,8BAA8B,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS,SArB1C;AAsBL,QAAA,0BAA0B,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS,SAtBtC;AAuBL,QAAA,4BAA4B,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS,SAvBxC;AAwBL,QAAA,YAAY,EAAE,YAAA;AAAM,iBAAA,SAAA;AAAS;AAxBxB,OAAP;AA0BD,KA3BwB;oBAAA;;AAAA,GAAzB;;AA2FA,EAAA,oBAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,SAAK,MAAL,GAAc,KAAK,OAAL,CAAa,QAAb,CAAsB,IAAtB,CAAd;AACA,SAAK,YAAL,GACI,KAAK,OAAL,CAAa,YAAb,CAA0B,UAAU,CAAC,UAArC,MAAqD,MADzD;AAEA,SAAK,aAAL,GACI,CAAC,CAAC,KAAK,OAAL,CAAa,kBAAb,CAAgC,UAAU,CAAC,aAA3C,CAAF,IACA,KAAK,OAAL,CAAa,kBAAb,CAAgC,UAAU,CAAC,aAA3C,MAA8D,MAFlE;AAGD,GAPD;;AASA,EAAA,oBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,YAAA;AACE,WAAO,KAAK,MAAZ;AACD,GAFD;;AAIA,EAAA,oBAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACE,WAAO,KAAK,YAAZ;AACD,GAFD;;AAIA,EAAA,oBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,KAAK,OAAT,EAAkB;AAChB;AACA;AACA;AACA;AACA,WAAK,IAAL;AACD,KAND,MAMO;AACL,WAAK,WAAL,GAAmB,UAAU,CAAC,YAAA;AAC5B,QAAA,KAAI,CAAC,IAAL;AACD,OAF4B,EAE1B,KAAK,WAFqB,CAA7B;AAGD;AACF,GAZD;;AAcA,EAAA,oBAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,UAAkB,GAAlB,EAAiC;AAAjC,QAAA,KAAA,GAAA,IAAA,CAAiC,CAC/B;AACA;AACA;;;AACO,QAAA,aAAA,GAAA,GAAA,CAAA,aAAA;AACP,QAAM,4BAA4B,GAAG,aAAa,YAAY,WAAzB,IACjC,KAAK,OAAL,CAAa,sBAAb,CAAoC,aAApC,CADJ,CAL+B,CAO/B;AACA;AACA;;AACA,QAAI,4BAAJ,EAAkC;AAChC;AACD;;AACD,SAAK,WAAL,GAAmB,UAAU,CAAC,YAAA;AAC5B,MAAA,KAAI,CAAC,IAAL;AACD,KAF4B,EAE1B,KAAK,WAFqB,CAA7B;AAGD,GAhBD;;AAkBA,EAAA,oBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,SAAK,gBAAL;AACA,SAAK,WAAL,GAAmB,UAAU,CAAC,YAAA;AAC5B,MAAA,KAAI,CAAC,IAAL;AACD,KAF4B,EAE1B,KAAK,WAFqB,CAA7B;AAGD,GALD;;AAOA,EAAA,oBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,GAAjB,EAAgC;AAC9B,QAAI,KAAK,MAAT,EAAiB;AACf,UAAM,mCAAmC,GACrC,GAAG,CAAC,aAAJ,YAA6B,WAA7B,IACA,KAAK,OAAL,CAAa,sBAAb,CAAoC,GAAG,CAAC,aAAxC,CAFJ,CADe,CAIf;;AACA,UAAI,mCAAJ,EAAyC;AACvC;AACD;AACF,KAT6B,CAU9B;;;AACA,SAAK,IAAL;AACD,GAZD;;AAcA,EAAA,oBAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,YAAA;AACE,QAAI,KAAK,OAAT,EAAkB;AAChB,WAAK,IAAL;AACD,KAFD,MAEO;AACL,WAAK,IAAL;AACD;AACF,GAND;;AAQA,EAAA,oBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,GAApB,EAAmC;AACjC,QAAM,oCAAoC,GACtC,GAAG,CAAC,MAAJ,YAAsB,WAAtB,KACC,KAAK,OAAL,CAAa,qBAAb,CAAmC,GAAG,CAAC,MAAvC,KACA,KAAK,OAAL,CAAa,sBAAb,CAAoC,GAAG,CAAC,MAAxC,CAFD,CADJ,CADiC,CAKjC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAI,KAAK,MAAL,IAAe,KAAK,YAApB,IACA,oCADJ,EAC0C;AACxC;AACD,KAfgC,CAgBjC;;;AACA,SAAK,IAAL;AACD,GAlBD;;AAoBA,EAAA,oBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,GAAd,EAAgC;AAC9B;AACA,QAAM,GAAG,GAAG,YAAY,CAAC,GAAD,CAAxB;;AACA,QAAI,GAAG,KAAK,GAAG,CAAC,MAAhB,EAAwB;AACtB,UAAM,4BAA4B,GAC9B,QAAQ,CAAC,aAAT,YAAkC,WAAlC,IACA,KAAK,OAAL,CAAa,sBAAb,CAAoC,QAAQ,CAAC,aAA7C,CAFJ;;AAGA,UAAI,4BAAJ,EAAkC;AAChC,aAAK,OAAL,CAAa,kBAAb;AACD;;AACD,WAAK,IAAL;AACD;AACF,GAZD;;AAcQ,EAAA,oBAAA,CAAA,SAAA,CAAA,2BAAA,GAAR,YAAA;AACE,SAAK,IAAL;AACD,GAFO;;AAIA,EAAA,oBAAA,CAAA,SAAA,CAAA,2BAAA,GAAR,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,SAAK,gBAAL;AACA,SAAK,WAAL,GAAmB,UAAU,CAAC,YAAA;AAC5B,MAAA,KAAI,CAAC,IAAL;AACD,KAF4B,EAE1B,KAAK,WAFqB,CAA7B;AAGD,GALO;;AAOA,EAAA,oBAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UAAkC,GAAlC,EAAiD;AAC/C,QAAM,2CAA2C,GAC7C,GAAG,CAAC,aAAJ,YAA6B,WAA7B,KACC,KAAK,OAAL,CAAa,qBAAb,CAAmC,GAAG,CAAC,aAAvC,KACA,KAAK,OAAL,CAAa,sBAAb,CAAoC,GAAG,CAAC,aAAxC,CAFD,CADJ,CAD+C,CAK/C;AACA;;AACA,QAAI,2CAAJ,EAAiD;AAC/C;AACD;;AACD,SAAK,IAAL;AACD,GAXO;AAaR;;;AAGG;;;AACK,EAAA,oBAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA,CAAA,CACE;AACA;AACA;;;AACA,SAAK,SAAL,CAAe,OAAf,CAAuB,aAAa,CAAC,WAArC,EAAkD,YAAA;AAChD,MAAA,KAAI,CAAC,6BAAL;AACD,KAFD;AAGD,GAPO;;AASR,EAAA,oBAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,SAAK,gBAAL;AACA,SAAK,gBAAL;;AAEA,QAAI,KAAK,OAAT,EAAkB;AAChB;AACD;;AAED,SAAK,OAAL,GAAe,IAAf;AACA,QAAM,kBAAkB,GAAG,KAAK,uBAAL,EAA3B;;AACA,QAAI,CAAC,kBAAkB,CAAC,oBAAxB,EAA8C;AAC5C,WAAK,OAAL,CAAa,YAAb,CAA0B,aAA1B,EAAyC,OAAzC;AACD;;AACD,QAAI,KAAK,MAAT,EAAiB;AACf,UAAI,KAAK,aAAT,EAAwB;AACtB,aAAK,OAAL,CAAa,kBAAb,CAAgC,eAAhC,EAAiD,MAAjD;AACD;;AACD,WAAK,OAAL,CAAa,oBAAb,CACI,UADJ,EACgB,KAAK,0BADrB;;AAEA,UAAI,CAAC,KAAK,YAAV,EAAwB;AACtB,aAAK,OAAL,CAAa,oBAAb,CACI,YADJ,EACkB,KAAK,4BADvB;AAEA,aAAK,OAAL,CAAa,oBAAb,CACI,YADJ,EACkB,KAAK,4BADvB;AAED;AACF;;AACD,SAAK,OAAL,CAAa,WAAb,CAAyB,IAAzB;AACA,SAAK,OAAL,CAAa,QAAb,CAAsB,OAAtB;;AACA,QAAI,KAAK,kBAAL,MAA6B,CAAC,KAAK,MAAvC,EAA+C;AAC7C,WAAK,OAAL,CAAa,QAAb,CAAsB,iBAAtB;AACD;;AACD,SAAK,UAAL,GAAkB,KAAK,OAAL,CAAa,qBAAb,EAAlB;AACA,SAAK,eAAL;AAEA,SAAK,OAAL,CAAa,4BAAb,CACI,OADJ,EACa,KAAK,oBADlB;AAEA,SAAK,OAAL,CAAa,4BAAb,CACI,SADJ,EACe,KAAK,sBADpB;AAGA,SAAK,OAAL,CAAa,0BAAb,CAAwC,QAAxC,EAAkD,KAAK,mBAAvD;AACA,SAAK,OAAL,CAAa,0BAAb,CAAwC,QAAxC,EAAkD,KAAK,mBAAvD;AAEA,SAAK,OAAL,GAAe,qBAAqB,CAAC,YAAA;AACnC,MAAA,KAAI,CAAC,wBAAL;;AACA,MAAA,KAAI,CAAC,OAAL,CAAa,QAAb,CAAsB,KAAtB;;AACA,MAAA,KAAI,CAAC,OAAL,CAAa,QAAb,CAAsB,kBAAtB;AACD,KAJmC,CAApC;AAKD,GA/CD;;AAiDA,EAAA,oBAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,SAAK,gBAAL;AACA,SAAK,gBAAL;;AAEA,QAAI,CAAC,KAAK,OAAV,EAAmB;AACjB;AACD;;AAED,QAAI,KAAK,OAAT,EAAkB;AAChB,MAAA,oBAAoB,CAAC,KAAK,OAAN,CAApB;AACD;;AAED,SAAK,OAAL,GAAe,KAAf;AACA,SAAK,OAAL,CAAa,YAAb,CAA0B,aAA1B,EAAyC,MAAzC;AACA,SAAK,OAAL,CAAa,sBAAb,CACI,UADJ,EACgB,KAAK,0BADrB;;AAEA,QAAI,KAAK,MAAT,EAAiB;AACf,UAAI,KAAK,aAAT,EAAwB;AACtB,aAAK,OAAL,CAAa,kBAAb,CAAgC,eAAhC,EAAiD,OAAjD;AACD;;AACD,UAAI,CAAC,KAAK,YAAV,EAAwB;AACtB,aAAK,OAAL,CAAa,sBAAb,CACI,YADJ,EACkB,KAAK,4BADvB;AAEA,aAAK,OAAL,CAAa,sBAAb,CACI,YADJ,EACkB,KAAK,4BADvB;AAED;AACF;;AACD,SAAK,wBAAL;AACA,SAAK,OAAL,CAAa,QAAb,CAAsB,IAAtB;AACA,SAAK,OAAL,CAAa,QAAb,CAAsB,eAAtB;AACA,SAAK,OAAL,CAAa,WAAb,CAAyB,KAAzB;AAEA,SAAK,OAAL,CAAa,8BAAb,CACI,OADJ,EACa,KAAK,oBADlB;AAEA,SAAK,OAAL,CAAa,8BAAb,CACI,SADJ,EACe,KAAK,sBADpB;AAEA,SAAK,OAAL,CAAa,4BAAb,CACI,QADJ,EACc,KAAK,mBADnB;AAEA,SAAK,OAAL,CAAa,4BAAb,CACI,QADJ,EACc,KAAK,mBADnB;AAED,GAxCD;;AA0CA,EAAA,oBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,YAAA;AACE,QAAM,eAAe,GAAG,KAAK,OAAL,CAAa,QAAb,CAAsB,IAAtB,CAAxB;AAEA,SAAK,OAAL,CAAa,WAAb,CAAyB,OAAzB;AACA,SAAK,OAAL,CAAa,WAAb,CAAyB,kBAAzB;AACA,SAAK,OAAL,CAAa,WAAb,CAAyB,IAAzB;AACA,SAAK,OAAL,CAAa,WAAb,CAAyB,eAAzB,EANF,CAQE;AACA;AACA;AACA;;AACA,QAAI,eAAJ,EAAqB;AACnB,WAAK,OAAL,CAAa,YAAb;AACD;AACF,GAfD;;AAiBQ,EAAA,oBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,YAAA;AACE,SAAK,OAAL,CAAa,WAAb,CAAyB,kBAAzB;AACA,SAAK,OAAL,CAAa,WAAb,CAAyB,eAAzB;AACD,GAHO;;AAKR,EAAA,oBAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UAAmB,QAAnB,EAAiE;AACxD,QAAA,IAAA,GAAA,QAAA,CAAA,IAAA;AAAA,QAAM,IAAA,GAAA,QAAA,CAAA,IAAN;;AACP,QAAI,IAAJ,EAAU;AACR,WAAK,WAAL,GAAmB,IAAnB;AACD;;AAED,QAAI,IAAJ,EAAU;AACR,WAAK,WAAL,GAAmB,IAAnB;AACD;AACF,GATD;;AAWA,EAAA,oBAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,IAAtB,EAA8C;AAC5C,QAAI,IAAI,KAAK,kBAAkB,CAAC,SAAhC,EAA2C;AACzC,WAAK,SAAL,GAAiB,OAAO,CAAC,oBAAzB;AACD,KAFD,MAEO;AACL,WAAK,SAAL,GAAiB,OAAO,CAAC,kBAAzB;AACD;AACF,GAND;;AAQQ,EAAA,oBAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,YAAA;AACE,QAAM,oBAAoB,GACtB,OAAO,CAAC,KAAK,OAAL,CAAa,kBAAb,CAAgC,iBAAhC,CAAD,CADX;AAEA,WAAO;AAAC,MAAA,oBAAoB,EAAA;AAArB,KAAP;AACD,GAJO;;AAMA,EAAA,oBAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,YAAA;AACE,QAAM,WAAW,GAAG,KAAK,OAAL,CAAa,cAAb,EAApB;AACA,WAAO,WAAW,CAAC,MAAZ,GAAqB,OAAO,CAAC,UAA7B,IACH,WAAW,CAAC,KAAZ,IAAqB,OAAO,CAAC,SADjC;AAED,GAJO;;AAMA,EAAA,oBAAA,CAAA,SAAA,CAAA,eAAA,GAAR,YAAA;AACQ,QAAA,EAAA,GAAA,KAAA,wBAAA,CAAA,KAAA,UAAA,CAAA;AAAA,QAAC,GAAA,GAAA,EAAA,CAAA,GAAD;AAAA,QAAM,IAAA,GAAA,EAAA,CAAA,IAAN;;AACN,SAAK,OAAL,CAAa,gBAAb,CAA8B,KAA9B,EAAwC,GAAG,GAAA,IAA3C;AACA,SAAK,OAAL,CAAa,gBAAb,CAA8B,MAA9B,EAAyC,IAAI,GAAA,IAA7C;AACD,GAJO;AAMR;;;;;;;;;;;;;AAaG;;;AACK,EAAA,oBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UAAiC,UAAjC,EAA4D;AAC1D,QAAI,CAAC,UAAL,EAAiB;AACf,aAAO;AAAC,QAAA,GAAG,EAAE,CAAN;AAAS,QAAA,IAAI,EAAE;AAAf,OAAP;AACD;;AAED,QAAM,WAAW,GAAG,KAAK,OAAL,CAAa,cAAb,EAApB;AACA,QAAM,GAAG,GAAG,KAAK,yBAAL,CAA+B,UAA/B,EAA2C,WAAW,CAAC,MAAvD,CAAZ;AACA,QAAM,IAAI,GAAG,KAAK,yBAAL,CAA+B,UAA/B,EAA2C,WAAW,CAAC,KAAvD,CAAb;AACA,WAAO;AAAC,MAAA,GAAG,EAAA,GAAJ;AAAM,MAAA,IAAI,EAAA;AAAV,KAAP;AACD,GATO;AAWR;;AAEG;;;AACK,EAAA,oBAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UACI,UADJ,EAC4B,YAD5B,EACgD;AAC9C,QAAM,KAAK,GAAG,CAAC,KAAK,OAAL,CAAa,KAAb,EAAf;AACA,QAAI,QAAJ,EAAc,MAAd,EAAsB,SAAtB;;AACA,QAAI,KAAK,MAAT,EAAiB;AACf,MAAA,QAAQ,GAAG,KAAK,GAAG,UAAU,CAAC,IAAX,GAAkB,YAArB,GAAoC,UAAU,CAAC,KAA/D;AACA,MAAA,MAAM,GAAG,KAAK,GAAG,UAAU,CAAC,KAAd,GAAsB,UAAU,CAAC,IAAX,GAAkB,YAAtD;AACD,KAHD,MAGO;AACL,MAAA,QAAQ,GAAG,KAAK,GAAG,UAAU,CAAC,IAAd,GAAqB,UAAU,CAAC,KAAX,GAAmB,YAAxD;AACA,MAAA,MAAM,GAAG,KAAK,GAAG,UAAU,CAAC,KAAX,GAAmB,YAAtB,GAAqC,UAAU,CAAC,IAA9D;AACA,MAAA,SAAS,GAAG,UAAU,CAAC,IAAX,GAAkB,CAAC,UAAU,CAAC,KAAX,GAAmB,YAApB,IAAoC,CAAlE;AACD;;AAED,QAAM,eAAe,GAAG,KAAK,MAAL,GACpB,KAAK,6BAAL,CAAmC,QAAnC,EAA6C,MAA7C,CADoB,GAEpB;AACA,SAAK,6BAAL,CAAmC,SAAnC,EAA+C,QAA/C,EAAyD,MAAzD,CAHJ;;AAKA,QAAI,KAAK,WAAL,KAAqB,SAAS,CAAC,KAA/B,IAAwC,eAAe,CAAC,GAAhB,CAAoB,QAApB,CAA5C,EAA2E;AACzE,aAAO,QAAP;AACD;;AACD,QAAI,KAAK,WAAL,KAAqB,SAAS,CAAC,GAA/B,IAAsC,eAAe,CAAC,GAAhB,CAAoB,MAApB,CAA1C,EAAuE;AACrE,aAAO,MAAP;AACD;;AACD,QAAI,KAAK,WAAL,KAAqB,SAAS,CAAC,MAA/B,IACA,eAAe,CAAC,GAAhB,CAAoB,SAApB,CADJ,EACoC;AAClC,aAAO,SAAP;AACD,KA1B6C,CA4B9C;AACA;;;AACA,QAAM,iBAAiB,GACnB,KAAK,MAAL,GAAc,CAAC,MAAD,EAAS,QAAT,CAAd,GAAmC,CAAC,SAAD,EAAY,QAAZ,EAAsB,MAAtB,CADvC;AAGA,QAAM,aAAa,GACf,iBAAiB,CAAC,IAAlB,CAAuB,UAAA,GAAA,EAAG;AAAI,aAAA,eAAe,CAAC,GAAhB,CAAA,GAAA,CAAA;AAAwB,KAAtD,CADJ;;AAEA,QAAI,aAAJ,EAAmB;AACjB,aAAO,aAAP;AACD,KArC6C,CAuC9C;AACA;AACA;AACA;AACA;;;AACA,QAAI,UAAU,CAAC,IAAX,GAAkB,CAAtB,EAAyB;AACvB,aAAO,KAAK,2BAAZ;AACD,KAFD,MAEO;AACL,UAAM,aAAa,GAAG,KAAK,OAAL,CAAa,gBAAb,EAAtB;AACA,aAAO,aAAa,IAAI,YAAY,GAAG,KAAK,2BAAxB,CAApB;AACD;AACF,GAnDO;AAqDR;;;;;;;;;;AAUG;;;AACK,EAAA,oBAAA,CAAA,SAAA,CAAA,6BAAA,GAAR,YAAA;;;AAAsC,QAAA,SAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAsB;AAAtB,MAAA,SAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACpC,QAAM,kBAAkB,GAAG,IAAI,GAAJ,EAA3B;AACA,QAAM,iBAAiB,GAAG,IAAI,GAAJ,EAA1B;;;AAEA,WAAuB,IAAA,WAAA,GAAA,QAAA,CAAA,SAAA,CAAA,EAAS,aAAA,GAAA,WAAA,CAAA,IAAA,EAAhC,EAAgC,CAAA,aAAA,CAAA,IAAhC,EAAgC,aAAA,GAAA,WAAA,CAAA,IAAA,EAAhC,EAAkC;AAA7B,YAAM,QAAQ,GAAA,aAAA,CAAA,KAAd;;AACH,YAAI,KAAK,+BAAL,CAAqC,QAArC,CAAJ,EAAoD;AAClD,UAAA,kBAAkB,CAAC,GAAnB,CAAuB,QAAvB;AACD,SAFD,MAEO,IAAI,KAAK,iCAAL,CAAuC,QAAvC,CAAJ,EAAsD;AAC3D,UAAA,iBAAiB,CAAC,GAAlB,CAAsB,QAAtB;AACD;AACF;;;;;;;;;;;;;AAED,WAAO,kBAAkB,CAAC,IAAnB,GAA0B,kBAA1B,GAA+C,iBAAtD;AACD,GAbO;;AAeA,EAAA,oBAAA,CAAA,SAAA,CAAA,+BAAA,GAAR,UAAwC,OAAxC,EAAuD;AACrD,QAAM,aAAa,GAAG,KAAK,OAAL,CAAa,gBAAb,EAAtB;AACA,QAAM,YAAY,GAAG,KAAK,OAAL,CAAa,cAAb,GAA8B,KAAnD;AAEA,WAAO,OAAO,GAAG,YAAV,IACH,aAAa,GAAG,KAAK,2BADlB,IAEH,OAAO,IAAI,KAAK,2BAFpB;AAGD,GAPO;;AASA,EAAA,oBAAA,CAAA,SAAA,CAAA,iCAAA,GAAR,UAA0C,OAA1C,EAAyD;AACvD,QAAM,aAAa,GAAG,KAAK,OAAL,CAAa,gBAAb,EAAtB;AACA,QAAM,YAAY,GAAG,KAAK,OAAL,CAAa,cAAb,GAA8B,KAAnD;AAEA,WAAO,OAAO,GAAG,YAAV,IAA0B,aAA1B,IAA2C,OAAO,IAAI,CAA7D;AACD,GALO;AAOR;;AAEG;;;AACK,EAAA,oBAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UACI,UADJ,EAC4B,aAD5B,EACiD;AAC/C,QAAM,SAAS,GAAG,UAAU,CAAC,MAAX,GAAoB,KAAK,SAA3C;AACA,QAAM,SAAS,GAAG,UAAU,CAAC,GAAX,IAAkB,KAAK,SAAL,GAAiB,aAAnC,CAAlB;AACA,QAAM,gBAAgB,GAClB,KAAK,8BAAL,CAAoC,SAApC,EAA+C,SAA/C,CADJ;;AAGA,QAAI,KAAK,WAAL,KAAqB,SAAS,CAAC,KAA/B,IACA,gBAAgB,CAAC,GAAjB,CAAqB,SAArB,CADJ,EACqC;AACnC,aAAO,SAAP;AACD,KAHD,MAGO,IACH,KAAK,WAAL,KAAqB,SAAS,CAAC,KAA/B,IACA,gBAAgB,CAAC,GAAjB,CAAqB,SAArB,CAFG,EAE8B;AACnC,aAAO,SAAP;AACD;;AAED,QAAI,gBAAgB,CAAC,GAAjB,CAAqB,SAArB,CAAJ,EAAqC;AACnC,aAAO,SAAP;AACD;;AAED,QAAI,gBAAgB,CAAC,GAAjB,CAAqB,SAArB,CAAJ,EAAqC;AACnC,aAAO,SAAP;AACD,KArB8C,CAuB/C;AACA;AACA;;;AACA,WAAO,SAAP;AACD,GA5BO;AA8BR;;;;;;;;;;AAUG;;;AACK,EAAA,oBAAA,CAAA,SAAA,CAAA,8BAAA,GAAR,UACI,cADJ,EAC4B,cAD5B,EACkD;AAChD,QAAM,kBAAkB,GAAG,IAAI,GAAJ,EAA3B;AACA,QAAM,iBAAiB,GAAG,IAAI,GAAJ,EAA1B;;AAEA,QAAI,KAAK,gCAAL,CAAsC,cAAtC,CAAJ,EAA2D;AACzD,MAAA,kBAAkB,CAAC,GAAnB,CAAuB,cAAvB;AACD,KAFD,MAEO,IAAI,KAAK,kCAAL,CAAwC,cAAxC,CAAJ,EAA6D;AAClE,MAAA,iBAAiB,CAAC,GAAlB,CAAsB,cAAtB;AACD;;AAED,QAAI,KAAK,gCAAL,CAAsC,cAAtC,CAAJ,EAA2D;AACzD,MAAA,kBAAkB,CAAC,GAAnB,CAAuB,cAAvB;AACD,KAFD,MAEO,IAAI,KAAK,kCAAL,CAAwC,cAAxC,CAAJ,EAA6D;AAClE,MAAA,iBAAiB,CAAC,GAAlB,CAAsB,cAAtB;AACD;;AAED,WAAO,kBAAkB,CAAC,IAAnB,GAA0B,kBAA1B,GAA+C,iBAAtD;AACD,GAlBO;;AAoBA,EAAA,oBAAA,CAAA,SAAA,CAAA,gCAAA,GAAR,UAAyC,IAAzC,EAAqD;AACnD,QAAM,cAAc,GAAG,KAAK,OAAL,CAAa,iBAAb,EAAvB;AACA,QAAM,aAAa,GAAG,KAAK,OAAL,CAAa,cAAb,GAA8B,MAApD;AAEA,WAAO,IAAI,GAAG,aAAP,GAAuB,KAAK,2BAA5B,IACH,cADG,IAEH,IAAI,IAAI,KAAK,2BAFjB;AAGD,GAPO;;AASA,EAAA,oBAAA,CAAA,SAAA,CAAA,kCAAA,GAAR,UAA2C,IAA3C,EAAuD;AACrD,QAAM,cAAc,GAAG,KAAK,OAAL,CAAa,iBAAb,EAAvB;AACA,QAAM,aAAa,GAAG,KAAK,OAAL,CAAa,cAAb,GAA8B,MAApD;AAEA,WAAO,IAAI,GAAG,aAAP,IAAwB,cAAxB,IAA0C,IAAI,IAAI,CAAzD;AACD,GALO;;AAOA,EAAA,oBAAA,CAAA,SAAA,CAAA,6BAAA,GAAR,YAAA;AACE,QAAM,aAAa,GAAG,KAAK,OAAL,CAAa,qBAAb,EAAtB;AACA,QAAI,CAAC,aAAD,IAAkB,CAAC,KAAK,UAA5B,EAAwC;;AAExC,QAAI,aAAa,CAAC,GAAd,KAAsB,KAAK,UAAL,CAAgB,GAAtC,IACA,aAAa,CAAC,IAAd,KAAuB,KAAK,UAAL,CAAgB,IADvC,IAEA,aAAa,CAAC,MAAd,KAAyB,KAAK,UAAL,CAAgB,MAFzC,IAGA,aAAa,CAAC,KAAd,KAAwB,KAAK,UAAL,CAAgB,KAH5C,EAGmD;AACjD,WAAK,UAAL,GAAkB,aAAlB;AACA,WAAK,eAAL;AACD;AACF,GAXO;;AAaA,EAAA,oBAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,YAAA;AACE,QAAI,KAAK,WAAT,EAAsB;AACpB,MAAA,YAAY,CAAC,KAAK,WAAN,CAAZ;AACA,WAAK,WAAL,GAAmB,IAAnB;AACD;AACF,GALO;;AAOA,EAAA,oBAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,YAAA;AACE,QAAI,KAAK,WAAT,EAAsB;AACpB,MAAA,YAAY,CAAC,KAAK,WAAN,CAAZ;AACA,WAAK,WAAL,GAAmB,IAAnB;AACD;AACF,GALO;;AAOR,EAAA,oBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACE,QAAI,KAAK,OAAT,EAAkB;AAChB,MAAA,oBAAoB,CAAC,KAAK,OAAN,CAApB;AACA,WAAK,OAAL,GAAe,IAAf;AACD;;AAED,SAAK,gBAAL;AACA,SAAK,gBAAL;AAEA,SAAK,OAAL,CAAa,WAAb,CAAyB,KAAzB;AACA,SAAK,OAAL,CAAa,WAAb,CAAyB,kBAAzB;AACA,SAAK,OAAL,CAAa,WAAb,CAAyB,OAAzB;AACA,SAAK,OAAL,CAAa,WAAb,CAAyB,IAAzB;AACA,SAAK,OAAL,CAAa,WAAb,CAAyB,eAAzB;;AAEA,QAAI,KAAK,MAAT,EAAiB;AACf,WAAK,OAAL,CAAa,sBAAb,CACI,UADJ,EACgB,KAAK,0BADrB;;AAEA,UAAI,CAAC,KAAK,YAAV,EAAwB;AACtB,aAAK,OAAL,CAAa,sBAAb,CACI,YADJ,EACkB,KAAK,4BADvB;AAEA,aAAK,OAAL,CAAa,sBAAb,CACI,YADJ,EACkB,KAAK,4BADvB;AAED;AACF;;AAED,SAAK,OAAL,CAAa,8BAAb,CACI,OADJ,EACa,KAAK,oBADlB;AAEA,SAAK,OAAL,CAAa,8BAAb,CACI,SADJ,EACe,KAAK,sBADpB;AAGA,SAAK,OAAL,CAAa,4BAAb,CACI,QADJ,EACc,KAAK,mBADnB;AAEA,SAAK,OAAL,CAAa,4BAAb,CACI,QADJ,EACc,KAAK,mBADnB;AAGA,SAAK,SAAL,CAAe,SAAf;AACD,GArCD;;AAsCF,SAAA,oBAAA;AAAC,CAnpBD,CAA0C,aAA1C,CAAA;;iCAqpBA;;AACA,eAAe,oBAAf","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport { __assign, __extends, __values } from \"tslib\";\nimport { AnimationFrame } from '@material/animation/animationframe';\nimport { MDCFoundation } from '@material/base/foundation';\nimport { KEY, normalizeKey } from '@material/dom/keyboard';\nimport { AnchorBoundaryType, attributes, CssClasses, numbers, XPosition, YPosition } from './constants';\nvar RICH = CssClasses.RICH, SHOWN = CssClasses.SHOWN, SHOWING = CssClasses.SHOWING, SHOWING_TRANSITION = CssClasses.SHOWING_TRANSITION, HIDE = CssClasses.HIDE, HIDE_TRANSITION = CssClasses.HIDE_TRANSITION, MULTILINE_TOOLTIP = CssClasses.MULTILINE_TOOLTIP;\nvar AnimationKeys;\n(function (AnimationKeys) {\n    AnimationKeys[\"POLL_ANCHOR\"] = \"poll_anchor\";\n})(AnimationKeys || (AnimationKeys = {}));\nvar MDCTooltipFoundation = /** @class */ (function (_super) {\n    __extends(MDCTooltipFoundation, _super);\n    function MDCTooltipFoundation(adapter) {\n        var _this = _super.call(this, __assign(__assign({}, MDCTooltipFoundation.defaultAdapter), adapter)) || this;\n        _this.isShown = false;\n        _this.anchorGap = numbers.BOUNDED_ANCHOR_GAP;\n        _this.xTooltipPos = XPosition.DETECTED;\n        _this.yTooltipPos = YPosition.DETECTED;\n        // Minimum threshold distance needed between the tooltip and the viewport.\n        _this.minViewportTooltipThreshold = numbers.MIN_VIEWPORT_TOOLTIP_THRESHOLD;\n        _this.hideDelayMs = numbers.HIDE_DELAY_MS;\n        _this.showDelayMs = numbers.SHOW_DELAY_MS;\n        _this.anchorRect = null;\n        _this.frameId = null;\n        _this.hideTimeout = null;\n        _this.showTimeout = null;\n        _this.animFrame = new AnimationFrame();\n        _this.documentClickHandler = function (evt) {\n            _this.handleDocumentClick(evt);\n        };\n        _this.documentKeydownHandler = function (evt) {\n            _this.handleKeydown(evt);\n        };\n        _this.richTooltipMouseEnterHandler = function () {\n            _this.handleRichTooltipMouseEnter();\n        };\n        _this.richTooltipMouseLeaveHandler = function () {\n            _this.handleRichTooltipMouseLeave();\n        };\n        _this.richTooltipFocusOutHandler = function (evt) {\n            _this.handleRichTooltipFocusOut(evt);\n        };\n        _this.windowScrollHandler = function () {\n            _this.handleWindowChangeEvent();\n        };\n        _this.windowResizeHandler = function () {\n            _this.handleWindowChangeEvent();\n        };\n        return _this;\n    }\n    Object.defineProperty(MDCTooltipFoundation, \"defaultAdapter\", {\n        get: function () {\n            return {\n                getAttribute: function () { return null; },\n                setAttribute: function () { return undefined; },\n                addClass: function () { return undefined; },\n                hasClass: function () { return false; },\n                removeClass: function () { return undefined; },\n                setStyleProperty: function () { return undefined; },\n                getViewportWidth: function () { return 0; },\n                getViewportHeight: function () { return 0; },\n                getTooltipSize: function () { return ({ width: 0, height: 0 }); },\n                getAnchorBoundingRect: function () {\n                    return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 });\n                },\n                getAnchorAttribute: function () { return null; },\n                setAnchorAttribute: function () { return null; },\n                isRTL: function () { return false; },\n                anchorContainsElement: function () { return false; },\n                tooltipContainsElement: function () { return false; },\n                focusAnchorElement: function () { return undefined; },\n                registerEventHandler: function () { return undefined; },\n                deregisterEventHandler: function () { return undefined; },\n                registerDocumentEventHandler: function () { return undefined; },\n                deregisterDocumentEventHandler: function () { return undefined; },\n                registerWindowEventHandler: function () { return undefined; },\n                deregisterWindowEventHandler: function () { return undefined; },\n                notifyHidden: function () { return undefined; },\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MDCTooltipFoundation.prototype.init = function () {\n        this.isRich = this.adapter.hasClass(RICH);\n        this.isPersistent =\n            this.adapter.getAttribute(attributes.PERSISTENT) === 'true';\n        this.isInteractive =\n            !!this.adapter.getAnchorAttribute(attributes.ARIA_EXPANDED) &&\n                this.adapter.getAnchorAttribute(attributes.ARIA_HASPOPUP) === 'true';\n    };\n    MDCTooltipFoundation.prototype.getIsRich = function () {\n        return this.isRich;\n    };\n    MDCTooltipFoundation.prototype.getIsPersistent = function () {\n        return this.isPersistent;\n    };\n    MDCTooltipFoundation.prototype.handleAnchorMouseEnter = function () {\n        var _this = this;\n        if (this.isShown) {\n            // Covers the instance where a user hovers over the anchor to reveal the\n            // tooltip, and then quickly navigates away and then back to the anchor.\n            // The tooltip should stay visible without animating out and then back in\n            // again.\n            this.show();\n        }\n        else {\n            this.showTimeout = setTimeout(function () {\n                _this.show();\n            }, this.showDelayMs);\n        }\n    };\n    MDCTooltipFoundation.prototype.handleAnchorFocus = function (evt) {\n        var _this = this;\n        // TODO(b/157075286): Need to add some way to distinguish keyboard\n        // navigation focus events from other focus events, and only show the\n        // tooltip on the former of these events.\n        var relatedTarget = evt.relatedTarget;\n        var tooltipContainsRelatedTarget = relatedTarget instanceof HTMLElement &&\n            this.adapter.tooltipContainsElement(relatedTarget);\n        // Do not show tooltip if the previous focus was on a tooltip element. This\n        // occurs when a rich tooltip is closed and focus is restored to the anchor\n        // or when user tab-navigates back into the anchor from the rich tooltip.\n        if (tooltipContainsRelatedTarget) {\n            return;\n        }\n        this.showTimeout = setTimeout(function () {\n            _this.show();\n        }, this.showDelayMs);\n    };\n    MDCTooltipFoundation.prototype.handleAnchorMouseLeave = function () {\n        var _this = this;\n        this.clearShowTimeout();\n        this.hideTimeout = setTimeout(function () {\n            _this.hide();\n        }, this.hideDelayMs);\n    };\n    MDCTooltipFoundation.prototype.handleAnchorBlur = function (evt) {\n        if (this.isRich) {\n            var tooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement &&\n                this.adapter.tooltipContainsElement(evt.relatedTarget);\n            // If focus changed to the tooltip element, don't hide the tooltip.\n            if (tooltipContainsRelatedTargetElement) {\n                return;\n            }\n        }\n        // Hide tooltip immediately on focus change.\n        this.hide();\n    };\n    MDCTooltipFoundation.prototype.handleAnchorClick = function () {\n        if (this.isShown) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    };\n    MDCTooltipFoundation.prototype.handleDocumentClick = function (evt) {\n        var anchorOrTooltipContainsTargetElement = evt.target instanceof HTMLElement &&\n            (this.adapter.anchorContainsElement(evt.target) ||\n                this.adapter.tooltipContainsElement(evt.target));\n        // For persistent rich tooltips, we will not hide if:\n        // - The click target is within the anchor element. Otherwise, both\n        //   the anchor element's click handler and this handler will handle the\n        //   click (due to event propagation), resulting in a shown tooltip\n        //   being immediately hidden if the tooltip was initially hidden.\n        // - The click target is within the tooltip element, since clicks\n        //   on the tooltip do not close the tooltip.\n        if (this.isRich && this.isPersistent &&\n            anchorOrTooltipContainsTargetElement) {\n            return;\n        }\n        // Hide the tooltip immediately on click.\n        this.hide();\n    };\n    MDCTooltipFoundation.prototype.handleKeydown = function (evt) {\n        // Hide the tooltip immediately on ESC key.\n        var key = normalizeKey(evt);\n        if (key === KEY.ESCAPE) {\n            var tooltipContainsActiveElement = document.activeElement instanceof HTMLElement &&\n                this.adapter.tooltipContainsElement(document.activeElement);\n            if (tooltipContainsActiveElement) {\n                this.adapter.focusAnchorElement();\n            }\n            this.hide();\n        }\n    };\n    MDCTooltipFoundation.prototype.handleRichTooltipMouseEnter = function () {\n        this.show();\n    };\n    MDCTooltipFoundation.prototype.handleRichTooltipMouseLeave = function () {\n        var _this = this;\n        this.clearShowTimeout();\n        this.hideTimeout = setTimeout(function () {\n            _this.hide();\n        }, this.hideDelayMs);\n    };\n    MDCTooltipFoundation.prototype.handleRichTooltipFocusOut = function (evt) {\n        var anchorOrTooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement &&\n            (this.adapter.anchorContainsElement(evt.relatedTarget) ||\n                this.adapter.tooltipContainsElement(evt.relatedTarget));\n        // If the focus is still within the anchor or the tooltip, do not hide the\n        // tooltip.\n        if (anchorOrTooltipContainsRelatedTargetElement) {\n            return;\n        }\n        this.hide();\n    };\n    /**\n     * On window resize or scroll, check the anchor position and size and\n     * repostion tooltip if necessary.\n     */\n    MDCTooltipFoundation.prototype.handleWindowChangeEvent = function () {\n        var _this = this;\n        // Since scroll and resize events can fire at a high rate, we throttle\n        // the potential re-positioning of tooltip component using\n        // requestAnimationFrame.\n        this.animFrame.request(AnimationKeys.POLL_ANCHOR, function () {\n            _this.repositionTooltipOnAnchorMove();\n        });\n    };\n    MDCTooltipFoundation.prototype.show = function () {\n        var _this = this;\n        this.clearHideTimeout();\n        this.clearShowTimeout();\n        if (this.isShown) {\n            return;\n        }\n        this.isShown = true;\n        var showTooltipOptions = this.parseShowTooltipOptions();\n        if (!showTooltipOptions.hideFromScreenreader) {\n            this.adapter.setAttribute('aria-hidden', 'false');\n        }\n        if (this.isRich) {\n            if (this.isInteractive) {\n                this.adapter.setAnchorAttribute('aria-expanded', 'true');\n            }\n            this.adapter.registerEventHandler('focusout', this.richTooltipFocusOutHandler);\n            if (!this.isPersistent) {\n                this.adapter.registerEventHandler('mouseenter', this.richTooltipMouseEnterHandler);\n                this.adapter.registerEventHandler('mouseleave', this.richTooltipMouseLeaveHandler);\n            }\n        }\n        this.adapter.removeClass(HIDE);\n        this.adapter.addClass(SHOWING);\n        if (this.isTooltipMultiline() && !this.isRich) {\n            this.adapter.addClass(MULTILINE_TOOLTIP);\n        }\n        this.anchorRect = this.adapter.getAnchorBoundingRect();\n        this.positionTooltip();\n        this.adapter.registerDocumentEventHandler('click', this.documentClickHandler);\n        this.adapter.registerDocumentEventHandler('keydown', this.documentKeydownHandler);\n        this.adapter.registerWindowEventHandler('scroll', this.windowScrollHandler);\n        this.adapter.registerWindowEventHandler('resize', this.windowResizeHandler);\n        this.frameId = requestAnimationFrame(function () {\n            _this.clearAllAnimationClasses();\n            _this.adapter.addClass(SHOWN);\n            _this.adapter.addClass(SHOWING_TRANSITION);\n        });\n    };\n    MDCTooltipFoundation.prototype.hide = function () {\n        this.clearHideTimeout();\n        this.clearShowTimeout();\n        if (!this.isShown) {\n            return;\n        }\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n        }\n        this.isShown = false;\n        this.adapter.setAttribute('aria-hidden', 'true');\n        this.adapter.deregisterEventHandler('focusout', this.richTooltipFocusOutHandler);\n        if (this.isRich) {\n            if (this.isInteractive) {\n                this.adapter.setAnchorAttribute('aria-expanded', 'false');\n            }\n            if (!this.isPersistent) {\n                this.adapter.deregisterEventHandler('mouseenter', this.richTooltipMouseEnterHandler);\n                this.adapter.deregisterEventHandler('mouseleave', this.richTooltipMouseLeaveHandler);\n            }\n        }\n        this.clearAllAnimationClasses();\n        this.adapter.addClass(HIDE);\n        this.adapter.addClass(HIDE_TRANSITION);\n        this.adapter.removeClass(SHOWN);\n        this.adapter.deregisterDocumentEventHandler('click', this.documentClickHandler);\n        this.adapter.deregisterDocumentEventHandler('keydown', this.documentKeydownHandler);\n        this.adapter.deregisterWindowEventHandler('scroll', this.windowScrollHandler);\n        this.adapter.deregisterWindowEventHandler('resize', this.windowResizeHandler);\n    };\n    MDCTooltipFoundation.prototype.handleTransitionEnd = function () {\n        var isHidingTooltip = this.adapter.hasClass(HIDE);\n        this.adapter.removeClass(SHOWING);\n        this.adapter.removeClass(SHOWING_TRANSITION);\n        this.adapter.removeClass(HIDE);\n        this.adapter.removeClass(HIDE_TRANSITION);\n        // If handleTransitionEnd is called after hiding the tooltip, the tooltip\n        // will have the HIDE class (before calling the adapter removeClass method).\n        // If tooltip is now hidden, send a notification that the animation has\n        // completed and the tooltip is no longer visible.\n        if (isHidingTooltip) {\n            this.adapter.notifyHidden();\n        }\n    };\n    MDCTooltipFoundation.prototype.clearAllAnimationClasses = function () {\n        this.adapter.removeClass(SHOWING_TRANSITION);\n        this.adapter.removeClass(HIDE_TRANSITION);\n    };\n    MDCTooltipFoundation.prototype.setTooltipPosition = function (position) {\n        var xPos = position.xPos, yPos = position.yPos;\n        if (xPos) {\n            this.xTooltipPos = xPos;\n        }\n        if (yPos) {\n            this.yTooltipPos = yPos;\n        }\n    };\n    MDCTooltipFoundation.prototype.setAnchorBoundaryType = function (type) {\n        if (type === AnchorBoundaryType.UNBOUNDED) {\n            this.anchorGap = numbers.UNBOUNDED_ANCHOR_GAP;\n        }\n        else {\n            this.anchorGap = numbers.BOUNDED_ANCHOR_GAP;\n        }\n    };\n    MDCTooltipFoundation.prototype.parseShowTooltipOptions = function () {\n        var hideFromScreenreader = Boolean(this.adapter.getAnchorAttribute('data-tooltip-id'));\n        return { hideFromScreenreader: hideFromScreenreader };\n    };\n    MDCTooltipFoundation.prototype.isTooltipMultiline = function () {\n        var tooltipSize = this.adapter.getTooltipSize();\n        return tooltipSize.height > numbers.MIN_HEIGHT &&\n            tooltipSize.width >= numbers.MAX_WIDTH;\n    };\n    MDCTooltipFoundation.prototype.positionTooltip = function () {\n        var _a = this.calculateTooltipDistance(this.anchorRect), top = _a.top, left = _a.left;\n        this.adapter.setStyleProperty('top', top + \"px\");\n        this.adapter.setStyleProperty('left', left + \"px\");\n    };\n    /**\n     * Calculates the position of the tooltip. A tooltip will be placed beneath\n     * the anchor element and aligned either with the 'start'/'end' edge of the\n     * anchor element or the 'center'.\n     *\n     * Tooltip alignment is selected such that the tooltip maintains a threshold\n     * distance away from the viewport (defaulting to 'center' alignment). If the\n     * placement of the anchor prevents this threshold distance from being\n     * maintained, the tooltip is positioned so that it does not collide with the\n     * viewport.\n     *\n     * Users can specify an alignment, however, if this alignment results in the\n     * tooltip colliding with the viewport, this specification is overwritten.\n     */\n    MDCTooltipFoundation.prototype.calculateTooltipDistance = function (anchorRect) {\n        if (!anchorRect) {\n            return { top: 0, left: 0 };\n        }\n        var tooltipSize = this.adapter.getTooltipSize();\n        var top = this.calculateYTooltipDistance(anchorRect, tooltipSize.height);\n        var left = this.calculateXTooltipDistance(anchorRect, tooltipSize.width);\n        return { top: top, left: left };\n    };\n    /**\n     * Calculates the `left` distance for the tooltip.\n     */\n    MDCTooltipFoundation.prototype.calculateXTooltipDistance = function (anchorRect, tooltipWidth) {\n        var isLTR = !this.adapter.isRTL();\n        var startPos, endPos, centerPos;\n        if (this.isRich) {\n            startPos = isLTR ? anchorRect.left - tooltipWidth : anchorRect.right;\n            endPos = isLTR ? anchorRect.right : anchorRect.left - tooltipWidth;\n        }\n        else {\n            startPos = isLTR ? anchorRect.left : anchorRect.right - tooltipWidth;\n            endPos = isLTR ? anchorRect.right - tooltipWidth : anchorRect.left;\n            centerPos = anchorRect.left + (anchorRect.width - tooltipWidth) / 2;\n        }\n        var positionOptions = this.isRich ?\n            this.determineValidPositionOptions(startPos, endPos) :\n            // For plain tooltips, centerPos is defined\n            this.determineValidPositionOptions(centerPos, startPos, endPos);\n        if (this.xTooltipPos === XPosition.START && positionOptions.has(startPos)) {\n            return startPos;\n        }\n        if (this.xTooltipPos === XPosition.END && positionOptions.has(endPos)) {\n            return endPos;\n        }\n        if (this.xTooltipPos === XPosition.CENTER &&\n            positionOptions.has(centerPos)) {\n            return centerPos;\n        }\n        // If no user position is supplied, rich tooltips default to end pos, then\n        // start position. Plain tooltips default to center, start, then end.\n        var possiblePositions = this.isRich ? [endPos, startPos] : [centerPos, startPos, endPos];\n        var validPosition = possiblePositions.find(function (pos) { return positionOptions.has(pos); });\n        if (validPosition) {\n            return validPosition;\n        }\n        // Indicates that all potential positions would result in the tooltip\n        // colliding with the viewport. This would only occur when the anchor\n        // element itself collides with the viewport, or the viewport is very\n        // narrow. In this case, we allow the tooltip to be mis-aligned from the\n        // anchor element.\n        if (anchorRect.left < 0) {\n            return this.minViewportTooltipThreshold;\n        }\n        else {\n            var viewportWidth = this.adapter.getViewportWidth();\n            return viewportWidth - (tooltipWidth + this.minViewportTooltipThreshold);\n        }\n    };\n    /**\n     * Given the values for the horizontal alignments of the tooltip, calculates\n     * which of these options would result in the tooltip maintaining the required\n     * threshold distance vs which would result in the tooltip staying within the\n     * viewport.\n     *\n     * A Set of values is returned holding the distances that would honor the\n     * above requirements. Following the logic for determining the tooltip\n     * position, if all alignments violate the threshold, then the returned Set\n     * contains values that keep the tooltip within the viewport.\n     */\n    MDCTooltipFoundation.prototype.determineValidPositionOptions = function () {\n        var e_1, _a;\n        var positions = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            positions[_i] = arguments[_i];\n        }\n        var posWithinThreshold = new Set();\n        var posWithinViewport = new Set();\n        try {\n            for (var positions_1 = __values(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {\n                var position = positions_1_1.value;\n                if (this.positionHonorsViewportThreshold(position)) {\n                    posWithinThreshold.add(position);\n                }\n                else if (this.positionDoesntCollideWithViewport(position)) {\n                    posWithinViewport.add(position);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (positions_1_1 && !positions_1_1.done && (_a = positions_1.return)) _a.call(positions_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;\n    };\n    MDCTooltipFoundation.prototype.positionHonorsViewportThreshold = function (leftPos) {\n        var viewportWidth = this.adapter.getViewportWidth();\n        var tooltipWidth = this.adapter.getTooltipSize().width;\n        return leftPos + tooltipWidth <=\n            viewportWidth - this.minViewportTooltipThreshold &&\n            leftPos >= this.minViewportTooltipThreshold;\n    };\n    MDCTooltipFoundation.prototype.positionDoesntCollideWithViewport = function (leftPos) {\n        var viewportWidth = this.adapter.getViewportWidth();\n        var tooltipWidth = this.adapter.getTooltipSize().width;\n        return leftPos + tooltipWidth <= viewportWidth && leftPos >= 0;\n    };\n    /**\n     * Calculates the `top` distance for the tooltip.\n     */\n    MDCTooltipFoundation.prototype.calculateYTooltipDistance = function (anchorRect, tooltipHeight) {\n        var belowYPos = anchorRect.bottom + this.anchorGap;\n        var aboveYPos = anchorRect.top - (this.anchorGap + tooltipHeight);\n        var yPositionOptions = this.determineValidYPositionOptions(aboveYPos, belowYPos);\n        if (this.yTooltipPos === YPosition.ABOVE &&\n            yPositionOptions.has(aboveYPos)) {\n            return aboveYPos;\n        }\n        else if (this.yTooltipPos === YPosition.BELOW &&\n            yPositionOptions.has(belowYPos)) {\n            return belowYPos;\n        }\n        if (yPositionOptions.has(belowYPos)) {\n            return belowYPos;\n        }\n        if (yPositionOptions.has(aboveYPos)) {\n            return aboveYPos;\n        }\n        // Indicates that all potential positions would result in the tooltip\n        // colliding with the viewport. This would only occur when the viewport is\n        // very short.\n        return belowYPos;\n    };\n    /**\n     * Given the values for above/below alignment of the tooltip, calculates\n     * which of these options would result in the tooltip maintaining the required\n     * threshold distance vs which would result in the tooltip staying within the\n     * viewport.\n     *\n     * A Set of values is returned holding the distances that would honor the\n     * above requirements. Following the logic for determining the tooltip\n     * position, if all possible alignments violate the threshold, then the\n     * returned Set contains values that keep the tooltip within the viewport.\n     */\n    MDCTooltipFoundation.prototype.determineValidYPositionOptions = function (aboveAnchorPos, belowAnchorPos) {\n        var posWithinThreshold = new Set();\n        var posWithinViewport = new Set();\n        if (this.yPositionHonorsViewportThreshold(aboveAnchorPos)) {\n            posWithinThreshold.add(aboveAnchorPos);\n        }\n        else if (this.yPositionDoesntCollideWithViewport(aboveAnchorPos)) {\n            posWithinViewport.add(aboveAnchorPos);\n        }\n        if (this.yPositionHonorsViewportThreshold(belowAnchorPos)) {\n            posWithinThreshold.add(belowAnchorPos);\n        }\n        else if (this.yPositionDoesntCollideWithViewport(belowAnchorPos)) {\n            posWithinViewport.add(belowAnchorPos);\n        }\n        return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;\n    };\n    MDCTooltipFoundation.prototype.yPositionHonorsViewportThreshold = function (yPos) {\n        var viewportHeight = this.adapter.getViewportHeight();\n        var tooltipHeight = this.adapter.getTooltipSize().height;\n        return yPos + tooltipHeight + this.minViewportTooltipThreshold <=\n            viewportHeight &&\n            yPos >= this.minViewportTooltipThreshold;\n    };\n    MDCTooltipFoundation.prototype.yPositionDoesntCollideWithViewport = function (yPos) {\n        var viewportHeight = this.adapter.getViewportHeight();\n        var tooltipHeight = this.adapter.getTooltipSize().height;\n        return yPos + tooltipHeight <= viewportHeight && yPos >= 0;\n    };\n    MDCTooltipFoundation.prototype.repositionTooltipOnAnchorMove = function () {\n        var newAnchorRect = this.adapter.getAnchorBoundingRect();\n        if (!newAnchorRect || !this.anchorRect)\n            return;\n        if (newAnchorRect.top !== this.anchorRect.top ||\n            newAnchorRect.left !== this.anchorRect.left ||\n            newAnchorRect.height !== this.anchorRect.height ||\n            newAnchorRect.width !== this.anchorRect.width) {\n            this.anchorRect = newAnchorRect;\n            this.positionTooltip();\n        }\n    };\n    MDCTooltipFoundation.prototype.clearShowTimeout = function () {\n        if (this.showTimeout) {\n            clearTimeout(this.showTimeout);\n            this.showTimeout = null;\n        }\n    };\n    MDCTooltipFoundation.prototype.clearHideTimeout = function () {\n        if (this.hideTimeout) {\n            clearTimeout(this.hideTimeout);\n            this.hideTimeout = null;\n        }\n    };\n    MDCTooltipFoundation.prototype.destroy = function () {\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n            this.frameId = null;\n        }\n        this.clearHideTimeout();\n        this.clearShowTimeout();\n        this.adapter.removeClass(SHOWN);\n        this.adapter.removeClass(SHOWING_TRANSITION);\n        this.adapter.removeClass(SHOWING);\n        this.adapter.removeClass(HIDE);\n        this.adapter.removeClass(HIDE_TRANSITION);\n        if (this.isRich) {\n            this.adapter.deregisterEventHandler('focusout', this.richTooltipFocusOutHandler);\n            if (!this.isPersistent) {\n                this.adapter.deregisterEventHandler('mouseenter', this.richTooltipMouseEnterHandler);\n                this.adapter.deregisterEventHandler('mouseleave', this.richTooltipMouseLeaveHandler);\n            }\n        }\n        this.adapter.deregisterDocumentEventHandler('click', this.documentClickHandler);\n        this.adapter.deregisterDocumentEventHandler('keydown', this.documentKeydownHandler);\n        this.adapter.deregisterWindowEventHandler('scroll', this.windowScrollHandler);\n        this.adapter.deregisterWindowEventHandler('resize', this.windowResizeHandler);\n        this.animFrame.cancelAll();\n    };\n    return MDCTooltipFoundation;\n}(MDCFoundation));\nexport { MDCTooltipFoundation };\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\nexport default MDCTooltipFoundation;\n//# sourceMappingURL=foundation.js.map"]},"metadata":{},"sourceType":"module"}